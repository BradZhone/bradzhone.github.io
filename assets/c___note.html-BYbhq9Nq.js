import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,o as i,c as o,a as t,b as a,d as r,e as c}from"./app-Coh1oo3x.js";const s={},p=t("h1",{id:"c-note",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#c-note"},[t("span",null,"C++ note")])],-1),d=t("h2",{id:"_1-类静态成员函数-变量",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_1-类静态成员函数-变量"},[t("span",null,"1. 类静态成员函数&变量")])],-1),h={href:"https://blog.csdn.net/weicao1990/article/details/81558328",target:"_blank",rel:"noopener noreferrer"},_=c("<ol><li>静态成员变量 <ol><li><p>static成员的所有者是类本身和对象，但是多个对象拥有一样的静态成员；</p></li><li><p>静态成员变量不能在类定义里边初始化，只能在class body外初始化。</p></li><li><p>静态成员仍然遵循public，private，protected访问准则。</p></li><li><p>静态成员函数没有this指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用。</p></li></ol></li><li>静态成员函数 <ol><li>出现在类体外的函数定义不能指定关键字static；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态成员变量和访问静态成员函数；</li><li>非静态成员函数可以任意地访问静态成员函数和静态成员变量；</li><li>静态成员函数不能访问非静态成员函数和非静态成员变量；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li><li>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，或者&quot;类名::静态成员函数名&quot;的方式调用;</li><li>当同一类的所有对象使用一个量时，对于这个共用的量，可以用静态数据成员变量，这个变量对于同一类的所有的对象都取相同的值。</li></ol></li></ol>",1);function m(u,g){const e=n("ExternalLinkIcon");return i(),o("div",null,[p,d,t("ul",null,[t("li",null,[t("a",h,[a("link"),r(e)])])]),_])}const f=l(s,[["render",m],["__file","c___note.html.vue"]]),C=JSON.parse(`{"path":"/notes/c___note.html","title":"C++ note","lang":"zh-CN","frontmatter":{"date":"2023-10-12T00:00:00.000Z","tag":["C++"],"category":["C++"],"description":"C++ note 1. 类静态成员函数&变量 link 静态成员变量 static成员的所有者是类本身和对象，但是多个对象拥有一样的静态成员； 静态成员变量不能在类定义里边初始化，只能在class body外初始化。 静态成员仍然遵循public，private，protected访问准则。 静态成员函数没有this指针，它不能返回非静态成员，因为除了...","head":[["meta",{"property":"og:url","content":"https://bradzhone.github.io/notes/c___note.html"}],["meta",{"property":"og:site_name","content":"BradZhone's Blog"}],["meta",{"property":"og:title","content":"C++ note"}],["meta",{"property":"og:description","content":"C++ note 1. 类静态成员函数&变量 link 静态成员变量 static成员的所有者是类本身和对象，但是多个对象拥有一样的静态成员； 静态成员变量不能在类定义里边初始化，只能在class body外初始化。 静态成员仍然遵循public，private，protected访问准则。 静态成员函数没有this指针，它不能返回非静态成员，因为除了..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"BradZhone"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:published_time","content":"2023-10-12T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++ note\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-12T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"BradZhone\\",\\"url\\":\\"https://github.com/BradZhone\\"}]}"]]},"headers":[{"level":2,"title":"1. 类静态成员函数&变量","slug":"_1-类静态成员函数-变量","link":"#_1-类静态成员函数-变量","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.4,"words":420},"filePathRelative":"notes/c++_note.md","localizedDate":"2023年10月12日","excerpt":"\\n<h2>1. 类静态成员函数&amp;变量</h2>\\n<ul>\\n<li><a href=\\"https://blog.csdn.net/weicao1990/article/details/81558328\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">link</a></li>\\n</ul>\\n<ol>\\n<li>静态成员变量\\n<ol>\\n<li>\\n<p>static成员的所有者是类本身和对象，但是多个对象拥有一样的静态成员；</p>\\n</li>\\n<li>\\n<p>静态成员变量不能在类定义里边初始化，只能在class body外初始化。</p>\\n</li>\\n<li>\\n<p>静态成员仍然遵循public，private，protected访问准则。</p>\\n</li>\\n<li>\\n<p>静态成员函数没有this指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用。</p>\\n</li>\\n</ol>\\n</li>\\n<li>静态成员函数\\n<ol>\\n<li>出现在类体外的函数定义不能指定关键字static；</li>\\n<li>静态成员之间可以相互访问，包括静态成员函数访问静态成员变量和访问静态成员函数；</li>\\n<li>非静态成员函数可以任意地访问静态成员函数和静态成员变量；</li>\\n<li>静态成员函数不能访问非静态成员函数和非静态成员变量；</li>\\n<li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li>\\n<li>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，或者\\"类名::静态成员函数名\\"的方式调用;</li>\\n<li>当同一类的所有对象使用一个量时，对于这个共用的量，可以用静态数据成员变量，这个变量对于同一类的所有的对象都取相同的值。</li>\\n</ol>\\n</li>\\n</ol>","autoDesc":true}`);export{f as comp,C as data};
